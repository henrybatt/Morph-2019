#pragma config(Sensor, S1,     frontIR,        sensorEV3_GenericI2C)
#pragma config(Sensor, S2,     backIR,         sensorEV3_GenericI2C)
#pragma config(Sensor, S4,     compass,        sensorEV3_GenericI2C)
#pragma config(Motor,  motorA,          frontRight,    tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          frontLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          backLeft,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorD,          backRight,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-irseeker-v2.h"
#include "hitechnic-compass.h"

#define SHORTSTR 130 // Ball Strength when it's close (for multiplier) (150)(180)
#define FARSTR 50 // Ball strength when it is far (for multiplier) (30)
#define MINSTR 10 // Ultra-weak IR signal threshold
#define STRAIGHTSTR 180 // To move forward (for moveAngle)
#define MOVESPEED 100 //Movement Speed of robot
#define COMPMULTI 1 //Compass Multiplier (0.7)

/* Global Variables*/
int target; // Heading of goal - Compass
int frontDir; // Directions - frontIR
int backDir; // Directions - backIR
int backStr; // Strength - backIR
int frontStr; // Strength - frontIR
int current; // Current Heading - Compass

/* Declaring the functions.*/
float max (float a, float b); // Maximum Value
float min (float a, float b); // Minimum Value
float constrain (float min, float max, float value); // Constraining values
void move(float angle, float speed, float rotation); // Movement of robot
int angle(int frontDir, int backDir, int frontStr, int backStr); // Angle of the ball

float multi (int x); // Multiplier for movement
int sign (int x); // Sign function

/* Main Code begins*/
task main()
{
	setLEDColor(ledRed); //Robot's light colour set to red

	/*Setting up a struct to hold data for the sensor.*/
	tHTIRS2 irSeeker1;
	tHTIRS2 irSeeker2;


	/*Initialising the IR sensors.*/
	initSensor(&irSeeker1, frontIR);
	initSensor(&irSeeker2, backIR);

	target = 2 * SensorValue[compass]; // Heading of goal is found (before forever loop)

	waitForButtonPress();// Waiting for any button to be pressed
	setLEDColor(ledGreen); // Sets the robot's colour back to green

	/* Forever loop begins*/
	while(true)
	{
		/*This is asking for a reading from the sensors.*/
		readSensor(&irSeeker1);
		readSensor(&irSeeker2);

		/*This is getting the data from the IR sensors and putting
		the different values to different variables.*/
		frontDir = irSeeker1.acDirection;
		backDir = irSeeker2.acDirection;
		frontStr = irSeeker1.enhStrength;
		backStr = irSeeker2.enhStrength;

		current = 2 * SensorValue(compass); // Current heading of robot is continuously found
		writeDebugStreamLine("%d", current);

		int ballAngle = angle(frontDir, backDir, frontStr, backStr); // The Ball Angle is derived through the function angle

		int ballStrength = max(frontStr, backStr);// The Ball Strength is equal to the higher value (frontStr or backStr)

		int moveAngle = 0; // Variable MoveAngle is established

		displayTextLine (9, "%d", ballStrength);
		displayTextLine (5, "%d", ballAngle);
		displayTextLine (6, "%d, %d", frontStr, backStr)

		/* This section controls how the robot should move dependent on the strength and direction of the ball. In this section,
		'Sign' is used to detetrmine the side of the robot that the ball is in. The multiplier determines at the size of the orbit around the ball,
		and this value is added in order to make the robot orbit around the ball*/
		int moveSpeed = MOVESPEED; //Setting the moveSpeed of the robot to the above defined value

		if (ballStrength < MINSTR) //If the robot cannot see the ball
		{
			moveSpeed = 0; // The movement speed is set to 0
		}
		else
		{

			if (abs(ballAngle) < 30) // If the angle of the ball is less than 20
			{
				if (frontStr > STRAIGHTSTR)
				{
					moveAngle = 0;
				}

				else
				{
					moveAngle = ballAngle * 0.5; // Go towards the ball (with tightener)
				}
			}

			else if (abs(ballAngle) <= 70) // If ballAngle is between 20 & 70
			{
				moveAngle = ballAngle + multi(ballStrength) * (45 * sign(ballAngle)); // Orbit around the ball(45)
			}
			else // If ballAngle >  70
			{
				moveAngle = ballAngle + multi(ballStrength) * (90 * sign(ballAngle));// Orbit around the ball(90)
			}

		}

		/* This function works out the compass correction using the inital (goal) and current values*/
		float rotation; // Declaring the variable rotation
		rotation = target - current; //Rotation is the heading of the goal, minus the current heading of the robot

		/* This section sets the direction the robot needs to face in a range of -180 to 180.*/
		if (rotation > 180)
		{
			rotation -= 360;
		}
		else if(rotation <= -180)
		{
			rotation += 360;
		}
		rotation *= COMPMULTI; //The rotation value is multiplied by the predefined muliplier, in order to change the sensitivity of the rotation

		move(-moveAngle, -moveSpeed , -rotation);

		displayTextLine (8, "%d", rotation);
		// writeDebugStreamLine("BallAngle: %d. Rotation: %d. MoveAngle: %d. FDir: %d. BDir: %d. FStr: %d. Bstr %d. Target %d. Current %d", ballAngle, rotation, moveAngle, frontDir, backDir, frontStr, backStr,target, current);
	}
}

/* This function uses mathematical logic, in order to find the higher value*/
float max (float a, float b)
{ if (a > b) // If a is greater than b
	{
		return a; // Return a
	}
	else // If b is greater than a
	{
		return b; // Return b
	}
}

/* This function uses mathematical logic, in order to find the lower value*/
float min (float a, float b)
{
	if (a < b) // If a is less than b
	{
		return a; // Return a
	}
	else // If b is less than a
	{
		return b; // Return b
	}
}

/* This function "brackets" (or constrains) the values so that it is not greater than the set range*/
float constrain (float min, float max, float value)
{
	if (value > max)
	{
		return max;
	}
	if (value < min)
	{
		return min;
	}
	else
	{
		return value;
	}
}

/* This function controls the movement of the robot, dependent on the angle of the ball, the speed required and the compass correction*/
void move(float angle, float speed, float rotation)// Intialising the function move with the paramaters angle, speed and rotation
{

	angle = 45 - angle;// This is since the motors are at a 45 degree angle, in relation to the position of the IR sensors (X&Y axis)
	float a = cosDegrees(angle); // Motor direction A is equal to the distance required, which is derived using trigonometry (cosine)
	float b = sinDegrees(angle);// Motor direction B is equal to the distance required, which is derived using trigonometry (sine)
	float fLeftspeed = b;
	float bRightspeed = -b;
	float fRightspeed = -a;
	float bLeftspeed = a;

	// writeDebugStreamLine("%d %d %d %d %d",angle, fLeftspeed,bRightspeed,fRightspeed,bLeftspeed);

	// Finding the absolute maximum of the motors
	float maxSpeed = max(fabs(fLeftspeed), fabs(bRightspeed));
	maxSpeed = max(fabs(maxSpeed), fabs(fRightspeed));
	maxSpeed = max(fabs(maxSpeed), fabs(bLeftspeed));

	maxSpeed = maxSpeed != 0 ? speed / maxSpeed : 0; // When maxSpeed is not equal to 0, it is equal to speed/maxSpeed

	/* This section finds the motor values for each of the motors dependent on the ball position and the compass correction*/
	fLeftspeed = fLeftspeed * maxSpeed + rotation;
	bRightspeed = bRightspeed * maxSpeed + rotation;
	fRightspeed = fRightspeed * maxSpeed + rotation;
	bLeftspeed = bLeftspeed * maxSpeed + rotation;

	// Finding the absolute max speed of the motors
	maxSpeed = max(abs(fLeftspeed), abs(bRightspeed));
	maxSpeed = max (abs(maxSpeed), abs(fRightspeed));
	maxSpeed = max (abs(maxSpeed), abs(bLeftspeed));




	if (maxSpeed > 100) //Reducing the speed of the motors in proportion, if the speed is greater than 100.
	{
		fLeftspeed = fLeftspeed / maxSpeed * 100;
		bRightspeed = bRightspeed / maxSpeed * 100;
		fRightspeed = fRightspeed / maxSpeed * 100;
		bLeftspeed = bLeftspeed / maxSpeed * 100;
	}

	/* Gives each of the motors a speed value using the calculations above*/
	/*
	motor[frontLeft] = fLeftspeed;
	motor[backRight] = bRightspeed;
	motor[frontRight] = fRightspeed;
	motor[backLeft] = bLeftspeed;
	*/
}

/* This function assigns sign a value dependent on the ballAngle*/
int sign (int x)
{
	if (x > 0) // If x is greater than 0
	{
		return 1; // Sign is equal to 1
	}
	else if (x < 0) // If x is less than 0
	{
		return -1; // Sign is equal -1
	}
	else // If x is equal to 0
	{
		return 0; // Sign is equal to 0
	}
}

/* This function substitutes each direction that the IR provides for an Angle, using the parameters below*/
int angle(int frontDir, int backDir, int frontStr, int backStr)
{
	int returnAngle = 0; //Variable returnAngle is established
	if (frontStr > backStr) //If the strength reading is greater on the frontIR
	{
		returnAngle = (frontDir-5)*(180/7); // The angle is calculated, using only 7 of the 9 directions given by the frontIR
	}
	else
	{
		returnAngle = (180 + (backDir-5)*(180/7));// The angle is calculated, using only 7 of the 9 directions given by the backIR
	}

	/* This sets the angle of the ball in a range of -180 to 180*/
	if (returnAngle > 180)
	{
		returnAngle -= 360;
	}
	else if (returnAngle < -180)
	{
		returnAngle += 360;
	}
	return returnAngle;
}

/* This function calculates a multiplier for movement*/
float multi (int x) //Where x is equal to the current ballStrength
{
	float value = (float)(x - FARSTR) / (float)(SHORTSTR - FARSTR);

	return constrain(0, 1, value); // Value is constrained to range of 0-1
}
